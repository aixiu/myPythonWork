#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 第一列为哨兵，即待插入值，排列好序列为有序区，未排的为无序区，一般用数列的第一位认定为有序区，
# 因为只有一个数字，之后的数列为无序区，比较时，从第二位开始，也就是无序区的第一位，取出来后放到
# 哨兵的位置，然后让有序区的数字依次和哨兵位置比较，数大的放后边。以此类推，直至把最后一个数字放
# 到哨兵位并比较，插入完成。
# 初始    0   1 9 8 5 6 
# 第一趟  9   1 9 8 5 6  把9取出来后即 1 8 5 6,然后用9和1比，比1大放到1后边，即 1 9 8 5 6 
# 第二趟  8   1 9 8 5 6  把8取出来后，和前两个数比，比1大放后边  最后为 1 8 9 5 6 
# 第三趟  5   1 8 9 5 6  把5取出来，和前三个比，最后为，1 5 8 9 6
# 第四趟  6   1 5 8 9 6  把6取出来，做比较  最后为  1 5 6 8 9 
# 最终结果为  1 5 6 8 9

# 代码实现

# 增加一个哨兵位，每轮比较将待比较数放入。
# 哨兵依次和待比较数的前一个数据比较，大数靠右移动，找到哨兵中值的插入位置
# 每一轮结束后，得到一个从开始到待比较数位置的一个有序序列

m_list = [1, 9, 8, 5, 6, 7, 4, 3, 2]

nums = [0] + m_list  # 增加哨兵位，，nums[0] 哨兵位 

# count_swap = 0   # 交换次数
count_iter = 0   # 迭代次数

length = len(nums)
for i in range(2, length):  # 从第二个数开始
    nums[0] = nums[i]    # 放置哨兵
    j = i - 1   # 设置哨兵前一位数字序号
    count_iter += 1
    if nums[j] > nums[0]:  # 大数向右移，找到插入位置
        while nums[j] > nums[0]:
            nums[j+1] = nums[j]   # 依次右移
            j -= 1
            # count_swap += 1
        nums[j+1] = nums[0]  #将哨兵插入，注意插入在右侧要+1
print(nums, count_iter)




# 练习题：